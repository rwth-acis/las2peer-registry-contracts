pragma solidity ^0.4.24;

import "./UserRegistry.sol";


/**
 * Service registry
 */
contract ServiceRegistry {
    UserRegistry public userRegistry;

    event ServiceCreated(
        bytes32 indexed name,
        bytes32 indexed author
    );

    event ServiceReleased(
        bytes32 indexed name,
        uint versionMajor,
        uint versionMinor,
        uint versionPatch
    );

    struct Release {
        bytes32 name;
        uint versionMajor; // TODO: do something with version?
        uint versionMinor;
        uint versionPatch;
        bytes signature; // TODO
    }

    mapping (bytes32 => bytes32) public serviceNameToAuthor;
    mapping (bytes32 => Release[]) public serviceNameToReleases;

    modifier onlyUserOwner(bytes32 userName) {
        // oh boy, this is all kinds of fun
        // 1. modifiers on imported contracts can't be accessed (only inherited), so we need to reimplement this here
        //     https://ethereum.stackexchange.com/questions/7306/importing-a-contract-does-not-access-to-its-modifiers
        // 2. state vars of the imported contract can't be accessed directly, but through autogenerated getters
        //     https://solidity.readthedocs.io/en/v0.4.24/contracts.html#visibility-and-getters
        // 3. returned structs magically turn into tuples
        //    https://medium.com/coinmonks/solidity-tutorial-returning-structs-from-public-functions-e78e48efb378
        // thank god this totally had intuitive error messages

        // https://solidity.readthedocs.io/en/v0.4.25/control-structures.html#destructuring-assignments-and-returning-multiple-values
        (,, address owner,) = userRegistry.users(userName);
        require(owner == msg.sender, "Sender must own claimed user name.");
        _;
    }

    modifier nonZero(bytes32 something) {
        require(something != 0, "Whatever this is, it must be non-zero.");
        _;
    }

    constructor(address userRegistryAddress) public {
        userRegistry = UserRegistry(userRegistryAddress);
    }

    function nameIsAvailable(bytes32 name) public view returns(bool) {
        return serviceNameToAuthor[name] == 0;
    }

    function register(
        bytes32 serviceName,
        bytes32 authorName
    )
        public
        nonZero(serviceName)
        nonZero(authorName)
        onlyUserOwner(authorName)
    {
        require(nameIsAvailable(serviceName), "Service name already taken.");

        serviceNameToAuthor[serviceName] = authorName;
        emit ServiceCreated(serviceName, authorName);
    }

    function release(
        bytes32 serviceName,
        bytes32 authorName,
        uint versionMajor,
        uint versionMinor,
        uint versionPatch
    )
        public
    {
        _release(Release(serviceName, versionMajor, versionMinor, versionPatch, ""), authorName);
    }

    function _release(Release r, bytes32 authorName) internal onlyUserOwner(authorName) {
        require(serviceNameToAuthor[r.name] == authorName, "Passed author does not own service.");

        serviceNameToReleases[r.name].push(r);
        emit ServiceReleased(r.name, r.versionMajor, r.versionMinor, r.versionPatch);
    }

    /*
        TODO: figure out what access method is appropriate (and possible)
        see test 'release can be accessed via public state variable'

    // returning mappings is not possible and not on the roadmap
    function getReleases() public view returns(mapping (bytes32 => Release[])) {
        return serviceNameToReleases;
    }

    // returning structs requires experimental compiler feature ABIEncoderV2
    function getReleases(bytes32 serviceName) public view returns(Release[]) {
        return serviceNameToReleases[serviceName];
    }

    // works, but handing the decomposed struct tuples requires web3.js beta release or a different client lib
    function getRelease(bytes32 serviceName, uint index) public view returns(Release) {
        return serviceNameToReleases[serviceName][index];
    }
    */
}
