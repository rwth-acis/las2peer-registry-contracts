pragma solidity ^0.4.24;

import "./UserRegistry.sol";


/**
 * Service registry
 */
contract ServiceRegistry {
    UserRegistry public userRegistry;

    event ServiceCreated(
        bytes32 indexed nameHash,
        bytes32 indexed author
    );

    event ServiceReleased(
        bytes32 indexed nameHash,
        Version version
    );

    struct Version {
        uint versionMajor;
        uint versionMinor;
        uint versionPatch;
    }

    struct Service {
        string name;
        bytes32 author;
        // TODO: extra data
    }

    mapping (bytes32 => Service) public services;
    mapping (bytes32 => Version[]) public serviceVersions;

    modifier onlyUserOwner(bytes32 userName) {
        // oh boy, this is all kinds of fun
        // 1. modifiers on imported contracts can't be accessed (only inherited), so we need to reimplement this here
        //     https://ethereum.stackexchange.com/questions/7306/importing-a-contract-does-not-access-to-its-modifiers
        // 2. state vars of the imported contract can't be accessed directly, but through autogenerated getters
        //     https://solidity.readthedocs.io/en/v0.4.24/contracts.html#visibility-and-getters
        // 3. returned structs magically turn into tuples
        //    https://medium.com/coinmonks/solidity-tutorial-returning-structs-from-public-functions-e78e48efb378
        // thank god this totally had intuitive error messages

        // https://solidity.readthedocs.io/en/v0.4.25/control-structures.html#destructuring-assignments-and-returning-multiple-values
        (,, address owner,) = userRegistry.users(userName);
        require(owner == msg.sender, "Sender must own claimed user name.");
        _;
    }

    modifier nonZero(bytes32 something) {
        require(something != 0, "Whatever this is, it must be non-zero.");
        _;
    }

    modifier nonZeroString(string something) {
        require(_stringHash(something) != _stringHash(""), "String must be non-zero.");
        _;
    }

    constructor(address userRegistryAddress) public {
        userRegistry = UserRegistry(userRegistryAddress);
    }

    function _stringHash(string name) internal pure returns(bytes32) {
        return keccak256(abi.encodePacked(name));
    }

    function _nameIsAvailable(string serviceName) public view returns(bool) {
        return _nameIsAvailable(_stringHash(serviceName));
    }

    function _nameIsAvailable(bytes32 hash) internal view returns(bool) {
        return services[hash].author == 0;
    }

    function register(
        string serviceName,
        bytes32 authorName
    )
        public
        nonZeroString(serviceName)
        nonZero(authorName)
        onlyUserOwner(authorName)
    {
        bytes32 hash = _stringHash(serviceName);
        require(_nameIsAvailable(hash), "Service name already taken.");

        services[hash] = Service(serviceName, authorName);
        emit ServiceCreated(hash, authorName);
    }

    function release(
        string serviceName,
        bytes32 authorName,
        uint versionMajor,
        uint versionMinor,
        uint versionPatch
    )
        public
    {
        _release(serviceName, authorName, Version(versionMajor, versionMinor, versionPatch));
    }

    function _release(string serviceName, bytes32 authorName, Version version) internal onlyUserOwner(authorName) {
        bytes32 hash = _stringHash(serviceName);
        require(services[hash].author == authorName, "Passed author does not own service.");

        serviceVersions[hash].push(version);
        emit ServiceReleased(hash, version);
    }
}
