pragma solidity ^0.4.24;
pragma experimental ABIEncoderV2;

import "./UserRegistry.sol";


/**
 * Service registry
 */
contract ServiceRegistry {
    UserRegistry public userRegistry;

    event ServiceCreated(
        bytes32 indexed nameHash,
        bytes32 indexed author
    );

    event ServiceReleased(
        bytes32 indexed nameHash,
        Version version
    );

    struct LongName {
        bytes32 part1;
        bytes32 part2;
        bytes32 part3;
        bytes32 part4;
    }

    struct Version {
        uint versionMajor;
        uint versionMinor;
        uint versionPatch;
    }

    struct Service {
        LongName name;
        bytes32 author;
        // TODO: extra data
    }

    mapping (bytes32 => Service) public services;
    mapping (bytes32 => Version[]) public serviceVersions;

    modifier onlyUserOwner(bytes32 userName) {
        // oh boy, this is all kinds of fun
        // 1. modifiers on imported contracts can't be accessed (only inherited), so we need to reimplement this here
        //     https://ethereum.stackexchange.com/questions/7306/importing-a-contract-does-not-access-to-its-modifiers
        // 2. state vars of the imported contract can't be accessed directly, but through autogenerated getters
        //     https://solidity.readthedocs.io/en/v0.4.24/contracts.html#visibility-and-getters
        // 3. returned structs magically turn into tuples
        //    https://medium.com/coinmonks/solidity-tutorial-returning-structs-from-public-functions-e78e48efb378
        // thank god this totally had intuitive error messages

        // https://solidity.readthedocs.io/en/v0.4.25/control-structures.html#destructuring-assignments-and-returning-multiple-values
        (,, address owner,) = userRegistry.users(userName);
        require(owner == msg.sender, "Sender must own claimed user name.");
        _;
    }

    modifier nonZero(bytes32 something) {
        require(something != 0, "Whatever this is, it must be non-zero.");
        _;
    }

    modifier nonZeroLongName(LongName name) {
        require(!(name.part1 == 0 && name.part2 == 0 && name.part3 == 0 && name.part3 == 0), "At least one part must be non-zero.");
        _;
    }

    constructor(address userRegistryAddress) public {
        userRegistry = UserRegistry(userRegistryAddress);
    }

    function _longNameHash(LongName n) internal pure returns(bytes32) {
        return keccak256(abi.encodePacked(n.part1, n.part2, n.part3, n.part4));
    }

    function nameIsAvailable(bytes32 namePart1, bytes32 namePart2, bytes32 namePart3, bytes32 namePart4) public view returns(bool) {
        return _nameIsAvailable(LongName(namePart1, namePart2, namePart3, namePart4));
    }

    function _nameIsAvailable(LongName name) internal view returns(bool) {
        return _nameIsAvailable(_longNameHash(name));
    }

    function _nameIsAvailable(bytes32 hash) internal view returns(bool) {
        return services[hash].author == 0;
    }

    function register(bytes32 serviceNamePart1, bytes32 serviceNamePart2, bytes32 serviceNamePart3, bytes32 serviceNamePart4, bytes32 authorName) public {
        _register(LongName(serviceNamePart1, serviceNamePart2, serviceNamePart3, serviceNamePart4), authorName);
    }

    function _register(
        LongName serviceName,
        bytes32 authorName
    )
        internal
        nonZeroLongName(serviceName)
        nonZero(authorName)
        onlyUserOwner(authorName)
    {
        bytes32 hash = _longNameHash(serviceName);
        require(_nameIsAvailable(hash), "Service name already taken.");

        services[hash] = Service(serviceName, authorName);
        emit ServiceCreated(hash, authorName);
    }

    function release(
        bytes32 serviceNamePart1,
        bytes32 serviceNamePart2,
        bytes32 serviceNamePart3,
        bytes32 serviceNamePart4,
        bytes32 authorName,
        uint versionMajor,
        uint versionMinor,
        uint versionPatch
    )
        public
    {
        _release(LongName(serviceNamePart1, serviceNamePart2, serviceNamePart3, serviceNamePart4), authorName, Version(versionMajor, versionMinor, versionPatch));
    }

    function _release(LongName serviceName, bytes32 authorName, Version version) internal onlyUserOwner(authorName) {
        bytes32 hash = _longNameHash(serviceName);
        require(services[hash].author == authorName, "Passed author does not own service.");

        serviceVersions[hash].push(version);
        emit ServiceReleased(hash, version);
    }
}
