pragma solidity ^0.4.24;

import "./UserRegistry.sol";

// possible TODO: move service name hash computation to clientside where possible

/**
 * Service registry
 */
contract ServiceRegistry {
    UserRegistry public userRegistry;

    event ServiceCreated(
        bytes32 indexed nameHash,
        bytes32 indexed author
    );

    event ServiceReleased(
        bytes32 indexed nameHash,
        //Version version // does not work, at least not with web3.js/truffle
        uint versionMajor,
        uint versionMinor,
        uint versionPatch
    );

    event ServiceDeployment(
        bytes32 indexed nameHash,
        string className,
        uint versionMajor,
        uint versionMinor,
        uint versionPatch,
        uint timestamp,
        string nodeId
    );

    struct Version {
        uint versionMajor;
        uint versionMinor;
        uint versionPatch;
    }

    struct Service {
        string name;
        bytes32 author;
    }

    struct Metadata {
        string dhtSupplement;
    }

    mapping (bytes32 => Service) public services;
    mapping (bytes32 => Version[]) public serviceVersions;
    mapping (bytes32 => Metadata[]) public serviceVersionMetadata;

    modifier onlyUserOwner(bytes32 userName) {
        // oh boy, this is all kinds of fun
        // 1. modifiers on imported contracts can't be accessed (only inherited), so we need to reimplement this here
        //     https://ethereum.stackexchange.com/questions/7306/importing-a-contract-does-not-access-to-its-modifiers
        // 2. state vars of the imported contract can't be accessed directly, but through autogenerated getters
        //     https://solidity.readthedocs.io/en/v0.4.24/contracts.html#visibility-and-getters
        // 3. returned structs magically turn into tuples
        //    https://medium.com/coinmonks/solidity-tutorial-returning-structs-from-public-functions-e78e48efb378
        // thank god this totally had intuitive error messages

        // https://solidity.readthedocs.io/en/v0.4.25/control-structures.html#destructuring-assignments-and-returning-multiple-values
        (,, address owner,) = userRegistry.users(userName);
        require(owner == msg.sender, "Sender must own claimed user name.");
        _;
    }

    modifier nonZero(bytes32 something) {
        require(something != 0, "Whatever this is, it must be non-zero.");
        _;
    }

    modifier nonZeroString(string something) {
        require(stringHash(something) != stringHash(""), "String must be non-zero.");
        _;
    }

    constructor(address userRegistryAddress) public {
        userRegistry = UserRegistry(userRegistryAddress);
    }

    function stringHash(string name) public pure returns(bytes32) {
        return keccak256(abi.encodePacked(name));
    }

    function nameIsAvailable(string serviceName) public view returns(bool) {
        return services[stringHash(serviceName)].author == 0;
    }

    function hashToName(bytes32 hashOfName) public view returns(string) {
        return services[hashOfName].name;
    }

    function register(
        string serviceName,
        bytes32 authorName
    )
        public
        nonZeroString(serviceName)
        nonZero(authorName)
        onlyUserOwner(authorName)
    {
        require(nameIsAvailable(serviceName), "Service name already taken.");
        bytes32 hash = stringHash(serviceName);
        services[hash] = Service(serviceName, authorName);
        emit ServiceCreated(hash, authorName);
    }

    function release(
        string serviceName,
        bytes32 authorName,
        uint versionMajor,
        uint versionMinor,
        uint versionPatch,
        string dhtSupplement
    )
    public
    onlyUserOwner(authorName)
    {
        bytes32 hash = stringHash(serviceName);
        require(services[hash].author == authorName, "Passed author does not own service.");

        serviceVersions[hash].push(Version(versionMajor, versionMinor, versionPatch));
        serviceVersionMetadata[hash].push(Metadata(dhtSupplement));
        emit ServiceReleased(hash, versionMajor, versionMinor, versionPatch);
    }

    // TODO: is there a way to ensure that the nodeId is "owned" by the sender?
    // of course not, since there's no concept of users owning nodes so far
    // we could let users sign the message to add some accountability instead
    function announceDeployment(
        string serviceName,
        string className,
        uint versionMajor,
        uint versionMinor,
        uint versionPatch,
        uint timestamp,
        string nodeId
    )
        public
    {
        emit ServiceDeployment(stringHash(serviceName), className, versionMajor, versionMinor, versionPatch, timestamp,
                               nodeId);
    }
}
